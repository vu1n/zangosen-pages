Here's the digest of the lobste.rs stories you provided:

---

## Why Nextcloud feels slow to use  
[Read more](https://ounapuu.ee/posts/2025/11/03/nextcloud-slow/)

### Key Takeaways:
1. The author expresses frustration over Nextcloud's perceived slowness, attributing it primarily to heavy JavaScript usage.
2. A clean page load can result in downloading **15-20 MB** of JavaScript, leading to long loading times, especially on slower connections.
3. The size of JavaScript files, particularly `core-common.js`, contributes to delayed interactions across various apps.
4. While aware of the need for multiple functions, the author suggests that the excessive bundle size negatively impacts the user experience.
5. Alternatives such as Vikunja showed significantly better performance with smaller JS sizes.

### Insightful Comment Points:
- **hy9grc**: Questions the claim that JS sizes alone are the problem, citing fast environments like Gmail with larger JS without slowness.
- **j56xdg**: Suggests that optimization should be applied to the delivery and loading of JS to address performance issues without heavy rework.
- **i8svnn**: Agrees on the performance concerns and expresses interest in lighter frontends for Nextcloud.

### Risks/Caveats:
- Performance issues may stem from factors beyond just JavaScript load, including server setup and how the services are architected.
- Comparing performance strictly on JS sizes can be misleading without considering network and caching strategies.

### Who Should Care & Why:
- **Nextcloud Users**: Those reliant on cloud services for productivity may need to consider alternatives or optimizations.
- **Web Developers**: Developers of web applications can learn from these performance pitfalls and prioritize code optimization.

### TL;DR:
Nextcloud’s performance suffers due to heavy JavaScript usage, impacting user experience significantly.

---

## Typst-Unlit: Write literate Haskell programs in Typst  
[Read more](http://cdn.oppi.li/typst-unlit.pdf)

### Key Takeaways:
1. The document introduces Typst-Unlit, a preprocessor for writing literate programs in Haskell using Typst.
2. It explains how to extract Haskell code from Typst, presenting technical call-and-response patterns.
3. The talk includes details on adapting the process with boilerplate requirements and how to simplify complex syntax.
4. There’s an emphasis on the practicalities of implementing processes and compiling the software efficiently.
5. It is accompanied with illustrative examples and detailed logical steps useful for developers.

### Insightful Comment Points:
- **pf5oyn**: Critiques the noise in triple backticks for code blocks and wishes for simpler syntax with indented blocks.
- **qzg1vk**: Shares additional resources where the document can be accessed in different formats for broader accessibility.
- **mg5jhm**: Questions how to add syntax highlighting for Haskell inside rendered documents and calls for clarity in implementation.

### Risks/Caveats:
- May face challenges in maintainability and standardization compared to existing systems due to customized approaches.
- Adoption depends on user familiarity with Haskell and Typst.

### Who Should Care & Why:
- **Haskell Developers**: Those looking for innovative documentation formats to enhance understanding of code.
- **Typst Users**: Users interested in writing documentation could bulk up their tools for code representation.

### TL;DR:
Typst-Unlit helps write literate Haskell programs using Typst, blending commentary and code into a seamless document.

---

## Error Codes for Control Flow  
[Read more](http://matklad.github.io/2025/11/06/error-codes-for-control-flow.html)

### Key Takeaways:
1. Distinction between error reporting and handling in programming is emphasized.
2. Zig’s approach to error handling through its type system is highlighted to safeguard against errors being easily ignored.
3. The article discusses the tension between providing meaningful error messaging and the overhead of error data.
4. A systematic way of handling errors in user-defined types is promoted for clarity in code management.
5. The article presents examples of how feedback loops between error presentation and action improve code quality.

### Insightful Comment Points:
- **hfmhh5**: Praises Zig's errors handling as beneficial for low-level programming efficiency while warning against the absence of error context.
- **2a06ya**: Suggests best practices for error handling that emphasizes explicit error sets for more robust code.
- **scmcli**: Critiques the lack of ergonomics when adopting Zig in higher-level application contexts.

### Risks/Caveats:
- Transitioning to Zig or adopting similar practices may require significant adjustments in existing codebases.
- For projects requiring detailed error reporting, additional overhead may deter adoption.

### Who Should Care & Why:
- **Systems Programmers**: Individuals working on performance-critical applications can benefit from Zig’s model.
- **Language Designers**: Decorators and error handling can inspire changes in existing languages to be more efficient.

### TL;DR:
Zig innovates error handling by separating error codes from error data, simplifying developer engagement with error states.

---

(to be continued as the output is lengthy...)